/* eslint-disable react/no-array-index-key */
import React from 'react';
import PropTypes from 'prop-types';
import classNames from 'classnames';
import badges from './helpers/icon-badges';
import { masks, maskIds } from './helpers/icon-masks';

import config from '../config';

const fetchCache = {};

class Icon extends React.Component {
  state = {
    svg: null
  }

  componentDidMount() {
    this._isMounted = true;
    this.getIcon(this.props);
  }

  componentWillReceiveProps(nextProps) {
    this.getIcon(nextProps);
  }

  componentWillUnmount() {
    this._isMounted = false;
  }

  /*
  * This is called when there is a pending request for the same Icon and it
  * hasn't been saved in local storage yet.
  */
  setStateFromPendingFetch = (uri) => {
    const cacheVal = fetchCache[uri];
    if (cacheVal && typeof cacheVal.then === 'function') { // we cached a promise of the fetch, so get the value that was (or is currently being) fetched
      cacheVal.then((data) => {
        // remove cached fetch promise
        delete fetchCache[uri];
        localStorage.setItem(uri, JSON.stringify(data.svg));

        if (this._isMounted) {
          this.setState({ svg: data.svg });
        }
      })
        .catch((e) => {
          if (e.name !== 'AbortError') {
            console.warn(`There was an error retrieving icon ${uri}. Reason: ${e.message}`); // eslint-disable-line no-console
            if (this._isMounted) {
              this.setState({ svg: null });
            }
          }
        });
    } else {
      // There was a problem if we hit this
      this.setState({ svg: null });
    }
  }

  getIcon = (props) => {
    const {
      icon,
      iconDisplay,
      badge,
      extension,
    } = props;
    let params = '';

    if (!icon || extension) {
      return;
    }

    if (iconDisplay) {
      params = `?iconDisplay=${iconDisplay}`;
    }

    if (badge) {
      params = iconDisplay ? `?iconDisplay=${iconDisplay}&badge=${badge}` : `?badge=${badge}`;
    }

    const uri = `${config.themeCore.svgIcons}/${icon}${params}`;

    // pull from localStorage, if available
    const cached = localStorage.getItem(uri);

    if (cached) {
      this.setState({ svg: JSON.parse(cached) });
      return;
    } else if (Object.prototype.hasOwnProperty.call(fetchCache, uri)) {
      // wait for pending request
      this.setStateFromPendingFetch(uri);
      return;
    }

    fetchCache[uri] = fetch(uri, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json; charset=UTF-8',
      },
    })
      .then((response) => {
        if (response.status >= 400 && this._isMounted) {
          this.setState({ svg: null });
        }

        return response.json();
      });

    // wait for pending request
    this.setStateFromPendingFetch(uri);
  }

  /*
  * The icon Api serializes the xml representation of the svg icon to json, when application/json mime type is set on request.
  * The serialization prefixes element attributes with an @ symbol. This returns the Javascript object properties
  * that start with an @ symbol.
  */
  getElementAttributes = (element) => {
    const attributes = {};

    Object.keys(element).forEach((key) => {
      if (key.substring(0, 1) === '@') {
        // ignore empty
        if (element[key] !== '') {
          // rename class attribute to className, for React compatibility
          const attributeName = key.substring(1) === 'class' ? 'className' : key.substring(1);
          attributes[attributeName] = element[key];
        }
      }
    });

    return attributes;
  }

  /*
  * Renders custom svg icon provided by consumer of this component.
  */
  renderExtensionIcon = () => {
    const {
      icon, iconDisplay, badge, extension,
    } = this.props;

    if (!extension) {
      return null;
    }

    let mask = '';
    let maskVector = '';
    let maskUrl = '';

    if (badge === 'add' || badge === 'help' || badge === 'minus') {
      mask = 'circle';
    } else if (badge === 'checkmark') {
      mask = 'checkmark';
    } else if (badge === 'error') {
      mask = 'octagon';
    } else if (badge === 'warning') {
      mask = 'triangle';
    }

    if (mask !== '') {
      maskUrl = `url(#${maskIds[mask]})`;
      maskVector = masks[mask];
    }

    const customIcons = extension(maskUrl);

    const itemClasses = classNames('PnnlIcon', iconDisplay);

    return (
      icon ?
        <svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100" className={itemClasses}>
          <defs>
            {maskVector}
          </defs>
          {customIcons[icon]}
          {(badge !== null && Object.keys(badges).includes(badge)) ? badges[badge] : null}
        </svg>
        : null
    );
  }

  renderChildElements = (element) => {
    const children = [];

    Object.keys(element).forEach((key, index) => {
      if (key.substring(0, 1) !== '@') {
        const attributes = this.getElementAttributes(element[key]);

        switch (key) {
          case 'rect':
            children.push((
              <rect {...attributes} key={index} />
            ));
            break;
          case 'path':
            children.push((
              <path {...attributes} key={index} />
            ));
            break;
          case 'circle':
            children.push((
              <circle {...attributes} key={index} />
            ));
            break;
          default:
            break;
        }
      }
    });

    return children;
  }

  render() {
    const { svg } = this.state;
    const { extension } = this.props;

    // Render custom icon if extension provided
    if (extension) {
      return (this.renderExtensionIcon());
    }

    if (!svg) {
      return null;
    }

    const svgAttributes = this.getElementAttributes(svg);
    let svgGroups = [];
    let maskAttributes = null;

    // mask definitions are only added for icons with a badge
    if (Object.prototype.hasOwnProperty.call(svg.defs, 'mask')) {
      maskAttributes = this.getElementAttributes(svg.defs.mask);
    }

    if (Object.prototype.hasOwnProperty.call(svg, 'g')) {
      // If there is only one group child, g is a single object, not an array
      if (Array.isArray(svg.g)) {
        svgGroups = svg.g;
      } else {
        svgGroups.push(svg.g);
      }
    }

    return (
      <svg {...svgAttributes}>
        <defs>
          {
            maskAttributes ? <mask {...maskAttributes}>{this.renderChildElements(svg.defs.mask)}</mask> : null
          }
        </defs>
        {svgGroups.map((group, index) => {
          const groupAttributes = this.getElementAttributes(group);
          let pathElements = [];
          let circleElements = [];

          // Expects g element to contain an array of path elements
          if (Object.prototype.hasOwnProperty.call(group, 'path')) {
            // If there is only one path child, path is a single object, not an array
            if (Array.isArray(group.path)) {
              pathElements = group.path;
            } else {
              pathElements.push(group.path);
            }
          }

          if (Object.prototype.hasOwnProperty.call(group, 'circle')) {
            // If there is only one circle child, path is a single object, not an array
            if (Array.isArray(group.circle)) {
              circleElements = group.circle;
            } else {
              circleElements.push(group.circle);
            }
          }

          return (
            <g {...groupAttributes} key={index}>
              {pathElements.map((p, pathIndex) => {
                const attributes = this.getElementAttributes(p);

                return (
                  <path {...attributes} key={pathIndex} />
                );
              })}
              {circleElements.map((p, pathIndex) => {
                const attributes = this.getElementAttributes(p);

                return (
                  <circle {...attributes} key={pathIndex + 20} />
                );
              })}
            </g>
          );
        })}
      </svg>
    );
  }
}

Icon.propTypes = {
  /**
    * An icon name. See e.g. https://forge.pnl.gov/icons/
    * */
  icon: PropTypes.string.isRequired,
  /**
     * Icon display options.  These are added as classNames to the resulting HTML. Built-in options are 'solid' or 'outline', and 'color'.
     */
  iconDisplay: PropTypes.string,
  /**
     * Name of the badge to display in the bottom right corner. Options are 'add', 'checkmark', 'help', 'error', 'minus', 'warning'.
     */
  badge: PropTypes.string,
  /**
     * A function to expand the default set of icons. Must return an object with SVG contained in a <g> element.
     */
  extension: PropTypes.func,
};

Icon.defaultProps = {
  iconDisplay: '',
  badge: null,
  extension: null,
};

export default Icon;
