'use strict';

exports.__esModule = true;

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _iconBadges = require('./helpers/icon-badges');

var _iconBadges2 = _interopRequireDefault(_iconBadges);

var _iconMasks = require('./helpers/icon-masks');

var _config = require('../config');

var _config2 = _interopRequireDefault(_config);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/* eslint-disable react/no-array-index-key */
var fetchCache = {};

var Icon = function (_React$Component) {
  (0, _inherits3['default'])(Icon, _React$Component);

  function Icon() {
    var _temp, _this, _ret;

    (0, _classCallCheck3['default'])(this, Icon);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3['default'])(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      svg: null
    }, _this.setStateFromPendingFetch = function (uri) {
      var cacheVal = fetchCache[uri];
      if (cacheVal && typeof cacheVal.then === 'function') {
        // we cached a promise of the fetch, so get the value that was (or is currently being) fetched
        cacheVal.then(function (data) {
          // remove cached fetch promise
          delete fetchCache[uri];
          localStorage.setItem(uri, (0, _stringify2['default'])(data.svg));

          if (_this._isMounted) {
            _this.setState({ svg: data.svg });
          }
        })['catch'](function (e) {
          if (e.name !== 'AbortError') {
            console.warn('There was an error retrieving icon ' + uri + '. Reason: ' + e.message); // eslint-disable-line no-console
            if (_this._isMounted) {
              _this.setState({ svg: null });
            }
          }
        });
      } else {
        // There was a problem if we hit this
        _this.setState({ svg: null });
      }
    }, _this.getIcon = function (props) {
      var icon = props.icon,
          iconDisplay = props.iconDisplay,
          badge = props.badge,
          extension = props.extension;

      var params = '';

      if (!icon || extension) {
        return;
      }

      if (iconDisplay) {
        params = '?iconDisplay=' + iconDisplay;
      }

      if (badge) {
        params = iconDisplay ? '?iconDisplay=' + iconDisplay + '&badge=' + badge : '?badge=' + badge;
      }

      var uri = _config2['default'].themeCore.svgIcons + '/' + icon + params;

      // pull from localStorage, if available
      var cached = localStorage.getItem(uri);

      if (cached) {
        _this.setState({ svg: JSON.parse(cached) });
        return;
      } else if (Object.prototype.hasOwnProperty.call(fetchCache, uri)) {
        // wait for pending request
        _this.setStateFromPendingFetch(uri);
        return;
      }

      fetchCache[uri] = fetch(uri, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json; charset=UTF-8'
        }
      }).then(function (response) {
        if (response.status >= 400 && _this._isMounted) {
          _this.setState({ svg: null });
        }

        return response.json();
      });

      // wait for pending request
      _this.setStateFromPendingFetch(uri);
    }, _this.getElementAttributes = function (element) {
      var attributes = {};

      (0, _keys2['default'])(element).forEach(function (key) {
        if (key.substring(0, 1) === '@') {
          // ignore empty
          if (element[key] !== '') {
            // rename class attribute to className, for React compatibility
            var attributeName = key.substring(1) === 'class' ? 'className' : key.substring(1);
            attributes[attributeName] = element[key];
          }
        }
      });

      return attributes;
    }, _this.renderExtensionIcon = function () {
      var _this$props = _this.props,
          icon = _this$props.icon,
          iconDisplay = _this$props.iconDisplay,
          badge = _this$props.badge,
          extension = _this$props.extension;


      if (!extension) {
        return null;
      }

      var mask = '';
      var maskVector = '';
      var maskUrl = '';

      if (badge === 'add' || badge === 'help' || badge === 'minus') {
        mask = 'circle';
      } else if (badge === 'checkmark') {
        mask = 'checkmark';
      } else if (badge === 'error') {
        mask = 'octagon';
      } else if (badge === 'warning') {
        mask = 'triangle';
      }

      if (mask !== '') {
        maskUrl = 'url(#' + _iconMasks.maskIds[mask] + ')';
        maskVector = _iconMasks.masks[mask];
      }

      var customIcons = extension(maskUrl);

      var itemClasses = (0, _classnames2['default'])('PnnlIcon', iconDisplay);

      return icon ? _react2['default'].createElement(
        'svg',
        { xmlns: 'http://www.w3.org/2000/svg', width: '100', height: '100', viewBox: '0 0 100 100', className: itemClasses },
        _react2['default'].createElement(
          'defs',
          null,
          maskVector
        ),
        customIcons[icon],
        badge !== null && (0, _keys2['default'])(_iconBadges2['default']).includes(badge) ? _iconBadges2['default'][badge] : null
      ) : null;
    }, _this.renderChildElements = function (element) {
      var children = [];

      (0, _keys2['default'])(element).forEach(function (key, index) {
        if (key.substring(0, 1) !== '@') {
          var attributes = _this.getElementAttributes(element[key]);

          switch (key) {
            case 'rect':
              children.push(_react2['default'].createElement('rect', (0, _extends3['default'])({}, attributes, { key: index })));
              break;
            case 'path':
              children.push(_react2['default'].createElement('path', (0, _extends3['default'])({}, attributes, { key: index })));
              break;
            case 'circle':
              children.push(_react2['default'].createElement('circle', (0, _extends3['default'])({}, attributes, { key: index })));
              break;
            default:
              break;
          }
        }
      });

      return children;
    }, _temp), (0, _possibleConstructorReturn3['default'])(_this, _ret);
  }

  Icon.prototype.componentDidMount = function componentDidMount() {
    this._isMounted = true;
    this.getIcon(this.props);
  };

  Icon.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    this.getIcon(nextProps);
  };

  Icon.prototype.componentWillUnmount = function componentWillUnmount() {
    this._isMounted = false;
  };

  /*
  * This is called when there is a pending request for the same Icon and it
  * hasn't been saved in local storage yet.
  */


  /*
  * The icon Api serializes the xml representation of the svg icon to json, when application/json mime type is set on request.
  * The serialization prefixes element attributes with an @ symbol. This returns the Javascript object properties
  * that start with an @ symbol.
  */


  /*
  * Renders custom svg icon provided by consumer of this component.
  */


  Icon.prototype.render = function render() {
    var _this2 = this;

    var svg = this.state.svg;
    var extension = this.props.extension;

    // Render custom icon if extension provided

    if (extension) {
      return this.renderExtensionIcon();
    }

    if (!svg) {
      return null;
    }

    var svgAttributes = this.getElementAttributes(svg);
    var svgGroups = [];
    var maskAttributes = null;

    // mask definitions are only added for icons with a badge
    if (Object.prototype.hasOwnProperty.call(svg.defs, 'mask')) {
      maskAttributes = this.getElementAttributes(svg.defs.mask);
    }

    if (Object.prototype.hasOwnProperty.call(svg, 'g')) {
      // If there is only one group child, g is a single object, not an array
      if (Array.isArray(svg.g)) {
        svgGroups = svg.g;
      } else {
        svgGroups.push(svg.g);
      }
    }

    return _react2['default'].createElement(
      'svg',
      svgAttributes,
      _react2['default'].createElement(
        'defs',
        null,
        maskAttributes ? _react2['default'].createElement(
          'mask',
          maskAttributes,
          this.renderChildElements(svg.defs.mask)
        ) : null
      ),
      svgGroups.map(function (group, index) {
        var groupAttributes = _this2.getElementAttributes(group);
        var pathElements = [];
        var circleElements = [];

        // Expects g element to contain an array of path elements
        if (Object.prototype.hasOwnProperty.call(group, 'path')) {
          // If there is only one path child, path is a single object, not an array
          if (Array.isArray(group.path)) {
            pathElements = group.path;
          } else {
            pathElements.push(group.path);
          }
        }

        if (Object.prototype.hasOwnProperty.call(group, 'circle')) {
          // If there is only one circle child, path is a single object, not an array
          if (Array.isArray(group.circle)) {
            circleElements = group.circle;
          } else {
            circleElements.push(group.circle);
          }
        }

        return _react2['default'].createElement(
          'g',
          (0, _extends3['default'])({}, groupAttributes, { key: index }),
          pathElements.map(function (p, pathIndex) {
            var attributes = _this2.getElementAttributes(p);

            return _react2['default'].createElement('path', (0, _extends3['default'])({}, attributes, { key: pathIndex }));
          }),
          circleElements.map(function (p, pathIndex) {
            var attributes = _this2.getElementAttributes(p);

            return _react2['default'].createElement('circle', (0, _extends3['default'])({}, attributes, { key: pathIndex + 20 }));
          })
        );
      })
    );
  };

  return Icon;
}(_react2['default'].Component);

Icon.propTypes = {
  /**
    * An icon name. See e.g. https://forge.pnl.gov/icons/
    * */
  icon: _propTypes2['default'].string.isRequired,
  /**
     * Icon display options.  These are added as classNames to the resulting HTML. Built-in options are 'solid' or 'outline', and 'color'.
     */
  iconDisplay: _propTypes2['default'].string,
  /**
     * Name of the badge to display in the bottom right corner. Options are 'add', 'checkmark', 'help', 'error', 'minus', 'warning'.
     */
  badge: _propTypes2['default'].string,
  /**
     * A function to expand the default set of icons. Must return an object with SVG contained in a <g> element.
     */
  extension: _propTypes2['default'].func
};

Icon.defaultProps = {
  iconDisplay: '',
  badge: null,
  extension: null
};

exports['default'] = Icon;
module.exports = exports['default'];